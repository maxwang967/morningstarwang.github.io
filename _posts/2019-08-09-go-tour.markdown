---
layout: post
title:  "A Tour to Golang"
date:   2019-07-31 20:30:28 +0800
categories: solution
---
## 前言

作为决定采用Go语言实现部分Web服务的初学者，笔者将从Golang官方的Tour出发，择出重点和部分可圈可点之处进行分析供其他初学者参考。

## Basic

### 导出名

“导出”与“未导出”是Go中对于封装的一个理解，并以首字母的大小写加以区分。下面代码段中，Println和Pi均是导出名，即可以被外部访问的名字，这里简单地理解为非private（对应Java）字段。当首字母为小写时，则是未导出的名字，外部不可访问。这里简单地理解为private字段。

```go
package main
import (
		"fmt"
		"math"
)

func main() {
		fmt.Println(math.Pi)
}
```

### 多值返回

函数可以返回任意数量的返回值，如下面代码段所示。

```go
package main

import "fmt"

func swap(x, y string) (string, string) {
		return y, x
}

func main() {
		a, b := swap("hello", "world")
		fmt.Println(a, b)
}
```

### 短变量声明

在函数中，简洁的赋值语句:=可以在类型明确的地方代替var声明。而函数外的语句都必须以关键字开始，故只能使用var声明变量。

```go
func main() {
		var i, j = 1, 2
		k := 3
}
```

### 基本数据类型

这里以代码块方式呈现。

```go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
```

全部的基本类型包括：

```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
    // 表示一个 Unicode 码点

float32 float64

complex64 complex128
```

### 零值

如果变量没有明确初始值则会被赋予零值，主要的零值包括：数值为0，布尔为false，字符串为空。

### 类型转换

Go语言在不同类型的项之间赋值，必须要进行显式转换。例如下面的代码块。

```go
i := 42
f := float64(i)
u := uint(f)
```

### 循环

Go语言只支持for循环，举例如下。

```go
sum := 0
for i :=0; i < 10; i++ {
		sum += i
}
//sum结果是45
```

一个标准的for循环可以简化，举例如下。

```go
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
	/**
	sum = 1
		2
		4
		8
		16
		32
		...
		512
		1024
	 */
//sum结果是1024
```

继续简化，可以把for当成while。

```go
sum := 1
for sum < 1000 {
		sum += sum
}
//sum结果是1024
```

我们还可以写一个极简的无限循环。

```go
for {
}
```

### 流程控制

if可以在条件表达式前执行一个简单的语句。

```go
if v := math.Pow(x, n); v < lim {
		return v
}
```

这里变量v的作用域还可以扩充到else中，例如。

```go
if v := math.Pow(x, n); v < lim {
		return v
} else {
		fmt.Printf("%g >= %g\n", v, lim)
}
	// 这里开始就不能使用 v 了
	return lim
```

一个简单地example：
为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。

计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：

```go
z -= (z*z - x) / (2*z)
```

重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。

在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 ...）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。

提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：

```go
z := 1.0
z := float64(1)
```

然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？

（*注：* 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。）

其实现是：

```go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
	z := 1.0
	for i := 0; i < 10; i++ {
		z -= (z*z - x) / (2 * z)
		fmt.Println(z)
	}
	return z
}

func main() {
	fmt.Println(Sqrt(2))
}
```

Go语言还可以使用没有条件的switch来更加清晰地表达一长串的if-then-else。其实现是：

```go
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```

Go语言拥有defer语句，可以将函数推迟到外层函数返回之后执行。推迟调用的函数**其参数会立即求值**，但**直到外层函数返回前该函数都不会被调用**。一个简明的举例如下：

```go
package main

import "fmt"

func main() {
	defer fmt.Println(a())
	fmt.Println("hello")
}

func a() string{
	fmt.Println("a")
	return "b"
}
//打印结果是：
// a
// hello
// b
```

使用defer推迟的函数调用会被压入栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

```go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
//counting
//done
//9
//8
//7
//6
//5
//4
//3
//2
//1
//0
```

### 更多数据类型

关于Go语言指针的使用，可以使用下面的代码块进行说明。

```go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // 指向 i
	fmt.Println(*p) // 通过指针读取 i 的值
	*p = 21         // 通过指针设置 i 的值
	fmt.Println(i)  // 查看 i 的值

	p = &j         // 指向 j
	*p = *p / 37   // 通过指针对 j 进行除法运算
	fmt.Println(j) // 查看 j 的值
}
//结果是:
//42
//21
//73
```

Go中的结构体可以按照如下方式定义：
```go
package main

import "fmt"

type Vertex struct {
		X int
		Y int
}

func main() {
		fmt.Println(Vertex{1, 2})
}
```

引用结构体时，也可以使用指针进行访问。

```go
v := Vertex{1, 2}
p := &v
p.X = 1e9
```

结构体可以使用下列方式来进行分配。

```go
var (
	v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
	v2 = Vertex{X: 1}  // Y:0 被隐式地赋予
	v3 = Vertex{}      // X:0 Y:0
	p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
)
```

数组声明如下：

```go
var a [2]string
a[0] = "Hello"
a[1] = "World"
fmt.Println(a[0], a[1])
fmt.Println(a)
primes := [6]int{2, 3, 5, 7, 11, 13}
fmt.Println(primes)
```

Go语言也存在与Python类似的切片，不存储任何数据，只描述了底层数组中的一段信息。

```go
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
```

需要注意的是，在Go语言的切片中，每生成一个切片都会对应创建一个底层数组。只有切片的头指针向后移动才会导致底层数组中的值丢失。下面这个例子能很好地说明这个问题。

```go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)//3,5,7

	s = s[:2]
	fmt.Println(s)//3,5

	s = s[1:]
	fmt.Println(s)//5
	
	s = s[1:4]
	fmt.Println(s)//7,11,13
}
```

